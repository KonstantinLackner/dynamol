#version 430

#define SPEED_THRESHOLD 0.0001

layout(local_size_x=1, local_size_y=1, local_size_z=1) in;

layout(rgba16_snorm) 
uniform image3D velocity;

layout(rgba16_snorm) 
uniform image3D quantity_r;

layout(rgba16_snorm) 
uniform image3D quantity_w;

uniform float delta_t;                      // Time step
uniform float dissipation = 1.0f;           // Dissipation factor
uniform float gs;

// Adding gravity in a separate shader would require more imageLoad calls so we do it here
uniform float gravity;

vec3 grid_clamp(vec3 v)
{
    return sign(v) * step(SPEED_THRESHOLD, abs(v));
}

ivec3 clamp_coord(ivec3 coord, ivec3 size)
{
    return clamp(coord, ivec3(0, 0, 0), size);
}

void advect_point(ivec3 coord)
{
    vec3 currentVelocity = imageLoad(velocity, coord).xyz;

    vec3 delta = delta_t * gs * currentVelocity;

    
    vec3 pos = coord - grid_clamp(delta);
    vec3 nearestPosNotI = floor(pos);
    ivec3 nearestPos = ivec3(nearestPosNotI.x, nearestPosNotI.y, nearestPosNotI.z);
    vec3 offset = pos - nearestPos;

    // y und z im naming vertauscht
    vec4 v000 = imageLoad(quantity_r, nearestPos);
    vec4 v010 = imageLoad(quantity_r, nearestPos + ivec3(0, 0, 1));
    vec4 v110 = imageLoad(quantity_r, nearestPos + ivec3(1, 0, 1));
    vec4 v100 = imageLoad(quantity_r, nearestPos + ivec3(1, 0, 0));
    vec4 v001 = imageLoad(quantity_r, nearestPos + ivec3(0, 1, 0));
    vec4 v011 = imageLoad(quantity_r, nearestPos + ivec3(0, 1, 1));
    vec4 v111 = imageLoad(quantity_r, nearestPos + ivec3(1, 1, 1));
    vec4 v101 = imageLoad(quantity_r, nearestPos + ivec3(1, 1, 0));

    vec4 u0 = v000 * (1-offset.x)*(1-offset.y)*(1-offset.z) + v100*offset.x*(1-offset.y)*(1-offset.z) + v010*(1-offset.x)*offset.y*(1-offset.z) + v001*(1-offset.x)*(1-offset.y)*offset.z + v011*(1-offset.x)*offset.y*offset.z + v101*offset.x*(1-offset.y)*offset.z + v110*offset.x*offset.y*(1-offset.z) + v111*offset.x*offset.y*offset.z;
    

    /*
    ivec3 pos0 = clamp_coord(ivec3(coord - grid_clamp(delta)), imageSize(quantity_r));

    vec4 inFront = imageLoad(quantity_r, pos0 + ivec3(0, 0, 1));
    vec4 behind = imageLoad(quantity_r, pos0 + ivec3(0, 0, -1));
    vec4 above = imageLoad(quantity_r, pos0 + ivec3(0, 1, 0));
    vec4 under = imageLoad(quantity_r, pos0 + ivec3(0, -1, 0));
    vec4 left = imageLoad(quantity_r, pos0 + ivec3(-1, 0, 0));
    vec4 right = imageLoad(quantity_r, pos0 + ivec3(1, 0, 0));
    vec4 u0 = (inFront + behind + above + under + left + right) / 6;
    
    vec4 u0 = imageLoad(quantity_r, pos0);
    */

    u0 *= dissipation;

    if (coord.x == 0 || coord.y == 0 || coord.z == 0) {
        u0 = vec4(0, 0, 0, 0);
    }

    //u0 += vec4(0, -gravity, 0, 0);
    imageStore(quantity_w, coord, u0);
}

void main()
{
    ivec3 coord = ivec3(gl_GlobalInvocationID);
    advect_point(coord);
}
